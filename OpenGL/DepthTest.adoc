= DepthTest

类似于**颜色缓冲**，在每个片段中存储深度信息（深度值），并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由**窗口系统自动创建**的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

当启用**深度测试**时，OpenGL会将一个片段的深度值与深度缓冲中的内容进行对比，如果测试通过，缓冲中的深度值被更新，如果测试失败，片段被丢弃。

深度测试运行在片段着色器之后（以及模板测试(Stencil Testing)运行之后）,可以通过 `GLSL` 的内建变量 `gl_FragCoord` 访问深度值，即Z分量。`gl_FragCoord` 的X、Y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。

* 启用深度测试：
+
[source,c]
----
glEnable(GL_DEPTH_TEST);
----
+
* 清除深度缓冲，就和颜色缓冲一样，否则使用将仍然是上一次渲染的深度值
+
[source,c]
----
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
----
+
* 设置一个**只读**的深度缓冲，即禁用对深度缓冲的写入：
+
[source,c]
----
glDepthMask(GL_FALSE); // <1>
----

<1> 只有当启用了深度测试才会生效

== 深度测试函数



.深度测试比较运算符
|===
|函数 | 描述 | 补充

| GL_ALWAYS
| 永远通过深度测试
| 效果同未启用深度测试时

| GL_NEVER
| 永远不通过深度测试
| 可用于绘制天空盒？

| GL_LESS
| 在片段深度值小于缓冲的深度值时通过测试
|

|GL_EQUAL
| 在片段深度值等于缓冲区的深度值时通过测试
|

|GL_LEQUAL
| 在片段深度值小于等于缓冲区的深度值时通过测试
|

|GL_GREATER
| 在片段深度值大于缓冲区的深度值时通过测试
|

|GL_NOTEQUAL
| 在片段深度值不等于缓冲区的深度值时通过测试
|

|GL_GEQUAL
| 在片段深度值大于等于缓冲区的深度值时通过测试
|
|===

== 深度测试精度

* 精度不够、丢失会导致 OpenGL 无法准确判断哪个片段应该在"上"，从而出现”争抢“;
* 离我们（摄像机）越远的片段，实际上所需要的精度越低，越近，所需要的精度应该越高:
+
[stem]
++++
F_(depth) = frac{1//z − 1//n\ear} {1//far−1//n\ear}
++++
+
* 变换深度值的方程已经嵌入到了**投影矩阵**中

== 深度冲突

在深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。

解决办法:

. 永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠
. 尽可能将近平面设置远一些
. 使用更高精度的深度缓冲
. 反向剔除
